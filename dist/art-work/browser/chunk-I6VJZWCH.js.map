{"version":3,"sources":["node_modules/@ngrx/signals/fesm2022/ngrx-signals.mjs","libs/core/src/lib/firestore/user.service.ts","libs/core/src/lib/auth/auth.store.ts","libs/core/src/lib/firestore/artwork.service.ts","libs/core/src/lib/firestore/artwork.store.ts","libs/core/src/lib/auth/auth.guard.ts"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { untracked, isSignal, computed, assertInInjectionContext, inject, Injector, effect, DestroyRef, signal, Injectable, linkedSignal } from '@angular/core';\nconst DEEP_SIGNAL = Symbol(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEEP_SIGNAL' : '');\nfunction toDeepSignal(signal) {\n  return new Proxy(signal, {\n    has(target, prop) {\n      return !!this.get(target, prop, undefined);\n    },\n    get(target, prop) {\n      const value = untracked(target);\n      if (!isRecord(value) || !(prop in value)) {\n        if (isSignal(target[prop]) && target[prop][DEEP_SIGNAL]) {\n          delete target[prop];\n        }\n        return target[prop];\n      }\n      if (!isSignal(target[prop])) {\n        Object.defineProperty(target, prop, {\n          value: computed(() => target()[prop]),\n          configurable: true\n        });\n        target[prop][DEEP_SIGNAL] = true;\n      }\n      return toDeepSignal(target[prop]);\n    }\n  });\n}\nconst nonRecords = [WeakSet, WeakMap, Promise, Date, Error, RegExp, ArrayBuffer, DataView, Function];\nfunction isRecord(value) {\n  if (value === null || typeof value !== 'object' || isIterable(value)) {\n    return false;\n  }\n  let proto = Object.getPrototypeOf(value);\n  if (proto === Object.prototype) {\n    return true;\n  }\n  while (proto && proto !== Object.prototype) {\n    if (nonRecords.includes(proto.constructor)) {\n      return false;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return proto === Object.prototype;\n}\nfunction isIterable(value) {\n  return typeof value?.[Symbol.iterator] === 'function';\n}\nfunction deepComputed(computation) {\n  return toDeepSignal(computed(computation));\n}\nfunction signalMethod(processingFn, config) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && !config?.injector) {\n    assertInInjectionContext(signalMethod);\n  }\n  const watchers = [];\n  const sourceInjector = config?.injector ?? inject(Injector);\n  const signalMethodFn = (input, config) => {\n    if (isReactiveComputation(input)) {\n      const callerInjector = getCallerInjector();\n      if (typeof ngDevMode !== 'undefined' && ngDevMode && config?.injector === undefined && callerInjector === undefined) {\n        console.warn('@ngrx/signals: The function returned by signalMethod was called', 'outside the injection context with a signal. This may lead to', 'a memory leak. Make sure to call it within the injection context', '(e.g. in a constructor or field initializer) or pass an injector', 'explicitly via the config parameter.\\n\\nFor more information, see:', 'https://ngrx.io/guide/signals/signal-method#automatic-cleanup');\n      }\n      const instanceInjector = config?.injector ?? callerInjector ?? sourceInjector;\n      const watcher = effect(() => {\n        const value = input();\n        untracked(() => processingFn(value));\n      }, {\n        ...(ngDevMode ? {\n          debugName: \"watcher\"\n        } : {}),\n        injector: instanceInjector\n      });\n      watchers.push(watcher);\n      instanceInjector.get(DestroyRef).onDestroy(() => {\n        const ix = watchers.indexOf(watcher);\n        if (ix !== -1) {\n          watchers.splice(ix, 1);\n        }\n      });\n      return watcher;\n    } else {\n      processingFn(input);\n      return {\n        destroy: () => void true\n      };\n    }\n  };\n  signalMethodFn.destroy = () => watchers.forEach(watcher => watcher.destroy());\n  return signalMethodFn;\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch {\n    return undefined;\n  }\n}\nfunction isReactiveComputation(value) {\n  return typeof value === 'function';\n}\nconst STATE_WATCHERS = new WeakMap();\nconst STATE_SOURCE = Symbol(typeof ngDevMode !== 'undefined' && ngDevMode ? 'STATE_SOURCE' : '');\nfunction isWritableSignal(value) {\n  return isSignal(value) && 'set' in value && 'update' in value && typeof value.set === 'function' && typeof value.update === 'function';\n}\nfunction isWritableStateSource(stateSource) {\n  const signals = stateSource[STATE_SOURCE];\n  return Reflect.ownKeys(stateSource[STATE_SOURCE]).every(key => {\n    return isWritableSignal(signals[key]);\n  });\n}\nfunction patchState(stateSource, ...updaters) {\n  const currentState = untracked(() => getState(stateSource));\n  const newState = updaters.reduce((nextState, updater) => ({\n    ...nextState,\n    ...(typeof updater === 'function' ? updater(nextState) : updater)\n  }), currentState);\n  const signals = stateSource[STATE_SOURCE];\n  const stateKeys = Reflect.ownKeys(stateSource[STATE_SOURCE]);\n  for (const key of Reflect.ownKeys(newState)) {\n    if (stateKeys.includes(key)) {\n      const signalKey = key;\n      if (currentState[signalKey] !== newState[signalKey]) {\n        signals[signalKey].set(newState[signalKey]);\n      }\n    } else if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      console.warn(`@ngrx/signals: patchState was called with an unknown state slice '${String(key)}'.`, 'Ensure that all state properties are explicitly defined in the initial state.', 'Updates to properties not present in the initial state will be ignored.');\n    }\n  }\n  notifyWatchers(stateSource);\n}\nfunction getState(stateSource) {\n  const signals = stateSource[STATE_SOURCE];\n  return Reflect.ownKeys(stateSource[STATE_SOURCE]).reduce((state, key) => {\n    const value = signals[key]();\n    return {\n      ...state,\n      [key]: value\n    };\n  }, {});\n}\nfunction watchState(stateSource, watcher, config) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && !config?.injector) {\n    assertInInjectionContext(watchState);\n  }\n  const injector = config?.injector ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  addWatcher(stateSource, watcher);\n  watcher(getState(stateSource));\n  const destroy = () => removeWatcher(stateSource, watcher);\n  destroyRef.onDestroy(destroy);\n  return {\n    destroy\n  };\n}\nfunction getWatchers(stateSource) {\n  return STATE_WATCHERS.get(stateSource[STATE_SOURCE]) || [];\n}\nfunction notifyWatchers(stateSource) {\n  const watchers = getWatchers(stateSource);\n  for (const watcher of watchers) {\n    const state = untracked(() => getState(stateSource));\n    watcher(state);\n  }\n}\nfunction addWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], [...watchers, watcher]);\n}\nfunction removeWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], watchers.filter(w => w !== watcher));\n}\nfunction signalState(initialState) {\n  const stateKeys = Reflect.ownKeys(initialState);\n  const stateSource = stateKeys.reduce((signalsDict, key) => ({\n    ...signalsDict,\n    [key]: signal(initialState[key])\n  }), {});\n  const signalState = computed(() => stateKeys.reduce((state, key) => ({\n    ...state,\n    [key]: stateSource[key]()\n  }), {}), {\n    ...(ngDevMode ? {\n      debugName: \"signalState\"\n    } : {})\n  });\n  Object.defineProperty(signalState, STATE_SOURCE, {\n    value: stateSource\n  });\n  for (const key of stateKeys) {\n    Object.defineProperty(signalState, key, {\n      value: toDeepSignal(stateSource[key])\n    });\n  }\n  return signalState;\n}\nfunction signalStore(...args) {\n  const signalStoreArgs = [...args];\n  const config = typeof signalStoreArgs[0] === 'function' ? {} : signalStoreArgs.shift();\n  const features = signalStoreArgs;\n  class SignalStore {\n    constructor() {\n      const innerStore = features.reduce((store, feature) => feature(store), getInitialInnerStore());\n      const {\n        stateSignals,\n        props,\n        methods,\n        hooks\n      } = innerStore;\n      const storeMembers = {\n        ...stateSignals,\n        ...props,\n        ...methods\n      };\n      this[STATE_SOURCE] = innerStore[STATE_SOURCE];\n      for (const key of Reflect.ownKeys(storeMembers)) {\n        this[key] = storeMembers[key];\n      }\n      const {\n        onInit,\n        onDestroy\n      } = hooks;\n      if (onInit) {\n        onInit();\n      }\n      if (onDestroy) {\n        inject(DestroyRef).onDestroy(onDestroy);\n      }\n    }\n    /** @nocollapse */\n    static Éµfac = function SignalStore_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SignalStore)();\n    };\n    /** @nocollapse */\n    static Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n      token: SignalStore,\n      factory: SignalStore.Éµfac,\n      providedIn: config.providedIn || null\n    });\n  }\n  (() => {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(SignalStore, [{\n      type: Injectable,\n      args: [{\n        providedIn: config.providedIn || null\n      }]\n    }], () => [], null);\n  })();\n  return SignalStore;\n}\nfunction getInitialInnerStore() {\n  return {\n    [STATE_SOURCE]: {},\n    stateSignals: {},\n    props: {},\n    methods: {},\n    hooks: {}\n  };\n}\nfunction signalStoreFeature(...args) {\n  const features = typeof args[0] === 'function' ? args : args.slice(1);\n  return inputStore => features.reduce((store, feature) => feature(store), inputStore);\n}\nfunction type() {\n  return undefined;\n}\nfunction assertUniqueStoreMembers(store, newMemberKeys) {\n  const storeMembers = {\n    ...store.stateSignals,\n    ...store.props,\n    ...store.methods\n  };\n  const overriddenKeys = Reflect.ownKeys(storeMembers).filter(memberKey => newMemberKeys.includes(memberKey));\n  if (overriddenKeys.length > 0) {\n    console.warn('@ngrx/signals: SignalStore members cannot be overridden.', 'Trying to override:', overriddenKeys.map(key => String(key)).join(', '));\n  }\n}\nfunction withProps(propsFactory) {\n  return store => {\n    const props = propsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, Reflect.ownKeys(props));\n    }\n    return {\n      ...store,\n      props: {\n        ...store.props,\n        ...props\n      }\n    };\n  };\n}\nfunction withComputed(computedFactory) {\n  return withProps(store => {\n    const computedResult = computedFactory(store);\n    const computedResultKeys = Reflect.ownKeys(computedResult);\n    return computedResultKeys.reduce((prev, key) => {\n      const signalOrComputation = computedResult[key];\n      return {\n        ...prev,\n        [key]: isSignal(signalOrComputation) ? signalOrComputation : computed(signalOrComputation)\n      };\n    }, {});\n  });\n}\n\n/**\n * @description\n * Allows passing properties, methods, or signals from a SignalStore\n * to a feature.\n *\n * @usageNotes\n * ```typescript\n * signalStore(\n *   withMethods((store) => ({\n *     load(id: number): Observable<Entity> {\n *       return of({ id, name: 'John' });\n *     },\n *   })),\n *   withFeature(\n *     // ðŸ‘‡ has full access to the store\n *     (store) => withEntityLoader((id) => firstValueFrom(store.load(id)))\n *   )\n * );\n * ```\n *\n * @param featureFactory function returning the actual feature\n */\nfunction withFeature(featureFactory) {\n  return store => {\n    const storeForFactory = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    };\n    return featureFactory(storeForFactory)(store);\n  };\n}\nfunction withHooks(hooksOrFactory) {\n  return store => {\n    const storeMembers = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    };\n    const hooks = typeof hooksOrFactory === 'function' ? hooksOrFactory(storeMembers) : hooksOrFactory;\n    const mergeHooks = (currentHook, hook) => {\n      return hook ? () => {\n        if (currentHook) {\n          currentHook();\n        }\n        hook(storeMembers);\n      } : currentHook;\n    };\n    return {\n      ...store,\n      hooks: {\n        onInit: mergeHooks(store.hooks.onInit, hooks.onInit),\n        onDestroy: mergeHooks(store.hooks.onDestroy, hooks.onDestroy)\n      }\n    };\n  };\n}\n\n/**\n * @description\n *\n * Adds linked state slices to a SignalStore.\n *\n * @usageNotes\n *\n * ```typescript\n * const OptionsStore = signalStore(\n *   withState({ options: [1, 2, 3] }),\n *   withLinkedState(({ options }) => ({\n *     selectedOption: () => options()[0],\n *   }))\n * );\n * ```\n *\n * This returns a state of type `{ options: number[], selectedOption: number | undefined }`.\n * When the `options` signal changes, the `selectedOption` automatically updates.\n *\n * For advanced use cases, `linkedSignal` or any other `WritableSignal` instance can be used within `withLinkedState`:\n *\n * ```typescript\n * type Option = { id: number; label: string };\n *\n * const OptionsStore = signalStore(\n *   withState({ options: [] as Option[] }),\n *   withLinkedState(({ options }) => ({\n *     selectedOption: linkedSignal<Option[], Option>({\n *       source: options,\n *       computation: (newOptions, previous) => {\n *         const option = newOptions.find((o) => o.id === previous?.value.id);\n *         return option ?? newOptions[0];\n *       },\n *     })\n *   }))\n * )\n * ```\n *\n * @param linkedStateFactory A function that returns an object literal with properties containing an actual `linkedSignal` or the computation function.\n */\nfunction withLinkedState(linkedStateFactory) {\n  return store => {\n    const linkedState = linkedStateFactory({\n      ...store.stateSignals,\n      ...store.props\n    });\n    const stateKeys = Reflect.ownKeys(linkedState);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, stateKeys);\n    }\n    const stateSource = store[STATE_SOURCE];\n    const stateSignals = {};\n    for (const key of stateKeys) {\n      const signalOrComputationFn = linkedState[key];\n      stateSource[key] = isWritableSignal(signalOrComputationFn) ? signalOrComputationFn : linkedSignal(signalOrComputationFn);\n      stateSignals[key] = toDeepSignal(stateSource[key]);\n    }\n    return {\n      ...store,\n      stateSignals: {\n        ...store.stateSignals,\n        ...stateSignals\n      }\n    };\n  };\n}\nfunction withMethods(methodsFactory) {\n  return store => {\n    const methods = methodsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, Reflect.ownKeys(methods));\n    }\n    return {\n      ...store,\n      methods: {\n        ...store.methods,\n        ...methods\n      }\n    };\n  };\n}\nfunction withState(stateOrFactory) {\n  return store => {\n    const state = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n    const stateKeys = Reflect.ownKeys(state);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, stateKeys);\n    }\n    const stateSource = store[STATE_SOURCE];\n    const stateSignals = {};\n    for (const key of stateKeys) {\n      stateSource[key] = signal(state[key]);\n      stateSignals[key] = toDeepSignal(stateSource[key]);\n    }\n    return {\n      ...store,\n      stateSignals: {\n        ...store.stateSignals,\n        ...stateSignals\n      }\n    };\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { deepComputed, getState, isWritableStateSource, patchState, signalMethod, signalState, signalStore, signalStoreFeature, type, watchState, withComputed, withFeature, withHooks, withLinkedState, withMethods, withProps, withState };\n","import { Injectable, inject } from '@angular/core';\nimport {\n  Firestore,\n  doc,\n  setDoc,\n  docData,\n  serverTimestamp,\n} from '@angular/fire/firestore';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { RegisterInput, UserDocument } from '../models/user.model';\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private readonly firestore = inject(Firestore);\n\n  async createUser(uid: string, data: RegisterInput): Promise<void> {\n    const userRef = doc(this.firestore, 'users', uid);\n    await setDoc(userRef, {\n      uid,\n      email: data.email,\n      firstName: data.firstName,\n      lastName: data.lastName,\n      displayName: data.displayName,\n      age: data.age,\n      createdAt: serverTimestamp(),\n    });\n  }\n\n  getUserSignal(uid: string) {\n    const userRef = doc(this.firestore, 'users', uid);\n    return toSignal(docData(userRef) as import('rxjs').Observable<UserDocument>, {\n      initialValue: null,\n    });\n  }\n}\n","import { computed, inject } from '@angular/core';\nimport { Router } from '@angular/router';\nimport {\n  Auth,\n  User as FirebaseUser,\n  confirmPasswordReset,\n  createUserWithEmailAndPassword,\n  onAuthStateChanged,\n  sendPasswordResetEmail,\n  signInWithEmailAndPassword,\n  signOut,\n  updateProfile,\n} from '@angular/fire/auth';\nimport {\n  patchState,\n  signalStore,\n  withComputed,\n  withHooks,\n  withMethods,\n  withState,\n} from '@ngrx/signals';\nimport { RegisterInput } from '../models/user.model';\nimport { UserService } from '../firestore/user.service';\n\ninterface AuthState {\n  currentUser: FirebaseUser | null;\n  isLoading: boolean;\n}\n\nconst initialState: AuthState = {\n  currentUser: null,\n  isLoading: true,\n};\n\nexport const AuthStore = signalStore(\n  { providedIn: 'root' },\n  withState(initialState),\n\n  withComputed(({ currentUser }) => ({\n    isAuthenticated: computed(() => currentUser() !== null),\n    uid: computed(() => currentUser()?.uid ?? null),\n  })),\n\n  withMethods((store) => {\n    const auth = inject(Auth);\n    const userService = inject(UserService);\n    const router = inject(Router);\n\n    return {\n      _setCurrentUser(user: FirebaseUser | null): void {\n        patchState(store, { currentUser: user, isLoading: false });\n      },\n\n      async login(email: string, password: string): Promise<void> {\n        await signInWithEmailAndPassword(auth, email, password);\n      },\n\n      async register(data: RegisterInput): Promise<void> {\n        const credential = await createUserWithEmailAndPassword(\n          auth,\n          data.email,\n          data.password,\n        );\n        await updateProfile(credential.user, { displayName: data.displayName });\n        await userService.createUser(credential.user.uid, data);\n      },\n\n      async forgotPassword(email: string): Promise<void> {\n        await sendPasswordResetEmail(auth, email);\n      },\n\n      async resetPassword(oobCode: string, newPassword: string): Promise<void> {\n        await confirmPasswordReset(auth, oobCode, newPassword);\n      },\n\n      async logout(): Promise<void> {\n        await signOut(auth);\n        await router.navigate(['/auth/login']);\n      },\n    };\n  }),\n\n  withHooks((store) => {\n    const auth = inject(Auth);\n    return {\n      onInit(): void {\n        onAuthStateChanged(auth, (user) => store._setCurrentUser(user));\n      },\n    };\n  }),\n);\n\nexport type AuthStore = InstanceType<typeof AuthStore>;\n","import { Injectable, inject } from '@angular/core';\nimport {\n  Firestore,\n  collection,\n  addDoc,\n  doc,\n  getDoc,\n  getDocs,\n  updateDoc,\n  deleteDoc,\n  CollectionReference,\n  DocumentData,\n} from '@angular/fire/firestore';\nimport { Artwork } from '../models/artwork.model';\n\n@Injectable({ providedIn: 'root' })\nexport class ArtworkService {\n  private readonly firestore = inject(Firestore);\n\n  private col(uid: string): CollectionReference<DocumentData> {\n    return collection(this.firestore, `users/${uid}/artworks`);\n  }\n\n  async getAll(uid: string): Promise<Artwork[]> {\n    const snap = await getDocs(this.col(uid));\n    return snap.docs.map((d) => ({ id: d.id, ...(d.data() as Omit<Artwork, 'id'>) }));\n  }\n\n  async getById(uid: string, id: string): Promise<Artwork | undefined> {\n    const ref = doc(this.col(uid), id);\n    const snap = await getDoc(ref);\n    if (!snap.exists()) return undefined;\n    return { id: snap.id, ...(snap.data() as Omit<Artwork, 'id'>) };\n  }\n\n  async create(uid: string, data: Omit<Artwork, 'id'>): Promise<string> {\n    const ref = await addDoc(this.col(uid), data as DocumentData);\n    return ref.id;\n  }\n\n  async update(uid: string, id: string, data: Partial<Omit<Artwork, 'id'>>): Promise<void> {\n    const ref = doc(this.col(uid), id);\n    await updateDoc(ref, data as DocumentData);\n  }\n\n  async delete(uid: string, id: string): Promise<void> {\n    const ref = doc(this.col(uid), id);\n    await deleteDoc(ref);\n  }\n}\n","import { computed, inject } from '@angular/core';\nimport {\n  patchState,\n  signalStore,\n  withComputed,\n  withMethods,\n  withState,\n} from '@ngrx/signals';\nimport { Artwork } from '../models/artwork.model';\nimport { ArtworkService } from './artwork.service';\n\ntype LoadStatus = 'idle' | 'loading' | 'loaded' | 'error';\n\ninterface ArtworkState {\n  artworks: Artwork[];\n  status: LoadStatus;\n  error: string | null;\n}\n\nconst initialState: ArtworkState = {\n  artworks: [],\n  status: 'idle',\n  error: null,\n};\n\nexport const ArtworkStore = signalStore(\n  { providedIn: 'root' },\n  withState(initialState),\n\n  withComputed(({ artworks, status }) => ({\n    isLoading: computed(() => status() === 'loading'),\n    totalCount: computed(() => artworks().length),\n    availableCount: computed(\n      () => artworks().filter((a) => a.status === 'Available').length,\n    ),\n    soldCount: computed(\n      () => artworks().filter((a) => a.status === 'Sold').length,\n    ),\n    revenue: computed(() =>\n      artworks()\n        .filter((a) => a.status === 'Sold')\n        .reduce((sum, a) => sum + a.price, 0),\n    ),\n  })),\n\n  withMethods((store) => {\n    const artworkService = inject(ArtworkService);\n\n    return {\n      async loadAll(uid: string): Promise<void> {\n        patchState(store, { status: 'loading', error: null });\n        try {\n          const artworks = await artworkService.getAll(uid);\n          patchState(store, { artworks, status: 'loaded' });\n        } catch {\n          patchState(store, { status: 'error', error: 'Failed to load artworks.' });\n        }\n      },\n\n      async create(uid: string, data: Omit<Artwork, 'id'>): Promise<string> {\n        const id = await artworkService.create(uid, data);\n        patchState(store, {\n          artworks: [...store.artworks(), { id, ...data }],\n        });\n        return id;\n      },\n\n      async update(\n        uid: string,\n        id: string,\n        data: Partial<Omit<Artwork, 'id'>>,\n      ): Promise<void> {\n        await artworkService.update(uid, id, data);\n        patchState(store, {\n          artworks: store\n            .artworks()\n            .map((a) => (a.id === id ? { ...a, ...data } : a)),\n        });\n      },\n\n      async remove(uid: string, id: string): Promise<void> {\n        await artworkService.delete(uid, id);\n        patchState(store, {\n          artworks: store.artworks().filter((a) => a.id !== id),\n        });\n      },\n    };\n  }),\n);\n\nexport type ArtworkStore = InstanceType<typeof ArtworkStore>;\n","import { inject } from '@angular/core';\nimport { CanActivateFn, Router } from '@angular/router';\nimport { AuthStore } from './auth.store';\n\n/** Redirects unauthenticated users to /auth/login */\nexport const authGuard: CanActivateFn = () => {\n  const authStore = inject(AuthStore);\n  const router = inject(Router);\n\n  if (authStore.isAuthenticated()) {\n    return true;\n  }\n\n  return router.createUrlTree(['/auth/login']);\n};\n\n/** Redirects already-authenticated users away from auth pages to /dashboard */\nexport const noAuthGuard: CanActivateFn = () => {\n  const authStore = inject(AuthStore);\n  const router = inject(Router);\n\n  if (!authStore.isAuthenticated()) {\n    return true;\n  }\n\n  return router.createUrlTree(['/dashboard']);\n};\n"],"mappings":"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","names":["signal","initialState"],"x_google_ignoreList":[0]}